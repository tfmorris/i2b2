/*
 * @(#) $RCSfile: ClusterStatsTable.java,v $ $Revision: 1.3 $ $Date: 2008/11/18 21:42:22 $ $Name: RELEASE_1_3_1_0001b $
 *
 * Center for Computational Genomics and Bioinformatics
 * Academic Health Center, University of Minnesota
 * Copyright (c) 2000-2002. The Regents of the University of Minnesota  
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * see: http://www.gnu.org/copyleft/gpl.html
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 */

package jcluto;

import javax.swing.table.*;

/**
 * ClusterStatsTable presents the stastics of a Clutolution as a TableModel, so
 * that they can be displayed in a JTable.
 * 
 * @author J Johnson
 * @version $Revision: 1.3 $ $Date: 2008/11/18 21:42:22 $ $Name
 */
public class ClusterStatsTable extends AbstractTableModel {
    ClutoSolution cs;
    // Columns
    // Cluster#
    // pWgts
    // cIntSim
    // cIntSdev
    // cExtSim
    // cExtSdev
    String colNames[] = { "Cluster", "# of Objects",
	    "Avg. Internal Similarity", "Std. Dev. of Internal Similarity",
	    "Avg. External Dissimilarity",
	    "Std. Dev. of External Dissimilarity", };

    /**
     * Create a TableModel for the similarity metrics of this clustering
     * solution.
     * 
     * @param clusterSolution
     *            the solution generated by a cluto clustering run.
     */
    public ClusterStatsTable(ClutoSolution clusterSolution) {
	cs = clusterSolution;
    }

    /**
     * Return the number rows in the table.
     * 
     * @return The number rows in the table.
     */
    public int getRowCount() {
	return cs.getParams().getNumClusters();
    }

    /**
     * Return the number columns in the table.
     * 
     * @return The number columns in the table.
     */
    public int getColumnCount() {
	return colNames.length;
    }

    /**
     * Returns the java Class of the values in this column.
     * 
     * @param ci
     *            the index of the column.
     * @return the java Class of the values in this column.
     */
    @Override
    public Class getColumnClass(int ci) {
	if (ci == 0) {
	    return java.lang.String.class;
	} else if (ci == 1) {
	    return java.lang.Integer.class;
	}
	return java.lang.Float.class;
    }

    /**
     * Returns the name of the column.
     * 
     * @param ci
     *            the index of the column.
     * @return the name of the column.
     */
    @Override
    public String getColumnName(int ci) {
	if (ci >= 0 && ci < colNames.length) {
	    return colNames[ci];
	}
	return "col_" + ci;
    }

    /**
     * Returns the value of the cell at the given row and columns indices.
     * 
     * @param ri
     *            the index of the row.
     * @param ci
     *            the index of the column.
     * @return the value of the cell.
     */
    public Object getValueAt(int ri, int ci) {
	if (ri >= 0 && ri < getRowCount()) {
	    switch (ci) {
	    case 0:
		return new Integer(ri);
	    case 1:
		int[] pWgts = cs.getPartWeights();
		return pWgts != null && ri < pWgts.length ? new Integer(
			pWgts[ri]) : null;
	    case 2:
		float[] cIntSim = cs.getIntSim();
		return cIntSim != null && ri < cIntSim.length ? new Float(
			cIntSim[ri]) : null;
	    case 3:
		float[] cIntSdev = cs.getIntStdDev();
		return cIntSdev != null && ri < cIntSdev.length ? new Float(
			cIntSdev[ri]) : null;
	    case 4:
		float[] cExtSim = cs.getExtSim();
		return cExtSim != null && ri < cExtSim.length ? new Float(
			cExtSim[ri]) : null;
	    case 5:
		float[] cExtSdev = cs.getExtStdDev();
		return cExtSdev != null && ri < cExtSdev.length ? new Float(
			cExtSdev[ri]) : null;
	    }
	}
	return null;
    }
}
